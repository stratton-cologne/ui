// scripts/generate-entries.mjs
// AUTO: baut src/entries/* neu aus src/components/*
//
// - Top-Level *.vue -> ./<name>
// - Subfolder mit index.ts -> ./<folder> (Barrel)
// - ignoriert: icons/, _private/
//
// Ausgaben in src/entries/*.ts mit Header-Kommentar.

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const root = path.resolve(__dirname, "..");
const srcDir = path.join(root, "src");
const componentsDir = path.join(srcDir, "components");
const entriesDir = path.join(srcDir, "entries");

const IGNORE_DIRS = new Set([
    "icons", // Icons werden separat als Rollup-Inputs gebaut
]);

/* ---------- utils ---------- */
function ensureDir(p) {
    fs.mkdirSync(p, { recursive: true });
}
function stripExt(p) {
    return p.replace(/\.(vue|ts|js|tsx|jsx)$/, "");
}
function isPrivateName(name) {
    return name.startsWith("_");
}

/* ---------- scans ---------- */
function scanTopLevelVue() {
    if (!fs.existsSync(componentsDir)) return [];
    const files = fs.readdirSync(componentsDir, { withFileTypes: true });
    return files
        .filter(
            (d) =>
                d.isFile() && d.name.endsWith(".vue") && !isPrivateName(d.name)
        )
        .map((d) => ({
            alias: `./${path.basename(d.name, ".vue")}`,
            target: `components/${d.name}`,
            kind: "vue",
        }));
}

function scanSubmoduleIndexTs() {
    if (!fs.existsSync(componentsDir)) return [];
    const subdirs = fs
        .readdirSync(componentsDir, { withFileTypes: true })
        .filter(
            (d) =>
                d.isDirectory() &&
                !isPrivateName(d.name) &&
                !IGNORE_DIRS.has(d.name)
        )
        .map((d) => d.name);

    const hits = [];
    for (const dir of subdirs) {
        const idxTs = path.join(componentsDir, dir, "index.ts");
        if (fs.existsSync(idxTs)) {
            hits.push({
                alias: `./${dir}`,
                target: `components/${dir}/index.ts`,
                kind: "barrel",
            });
        }
    }
    return hits;
}

/* ---------- writer ---------- */
function writeEntry({ alias, target, kind }) {
    const fileName = alias.replace(/^\.\//, "") + ".ts"; // z.B. forms.ts
    const out = path.join(entriesDir, fileName);
    const rel = stripExt(target);

    let content = `// AUTO-GENERATED BY scripts/generate-entries.mjs â€” DO NOT EDIT\n`;
    if (kind === "vue") {
        content += `export { default } from '../${target}';\n`;
    } else {
        // Barrel (index.ts)
        content += `export * from '../${rel}';\n`;
    }

    ensureDir(path.dirname(out));
    fs.writeFileSync(out, content, "utf8");
    return `  ${alias} -> ${target}`;
}

/* ---------- main ---------- */
(function main() {
    // Clean entries dir (nur generierte Dateien)
    fs.rmSync(entriesDir, { recursive: true, force: true });
    ensureDir(entriesDir);

    const entries = [
        ...scanTopLevelVue(),
        ...scanSubmoduleIndexTs(), // z.B. ./forms automatisch, sobald components/forms/index.ts existiert
    ];

    const lines = entries.map(writeEntry);
    console.log(
        "[sc/ui] Generated entries:\n" +
            (lines.length ? lines.join("\n") : "  (none)")
    );
})();
